Primality Test
===============
소수판정 알고리즘에는 결정적 소수판정 알고리즘(Deterministic Algorithm)과 확률적 소수판정 알고리즘(Probabilistic Algorithm) 으로 나누어진다.<br>
<br>
결정적 소수판정 알고리즘(Deterministic Algorithm)에는 에라토스테네스의 방법, 페르마의 방법 윌슨 방법 등이 있고, 확률적 소수판정 알고리즘(Probabilistic Algorithm)에는 틀릴 확률이 존재하지만 빠르게 높은 확률의 답을 얻을 수 있다. Solovay-Strassen 알고리즘, Lehmann-Peralta 알고리즘, Miller-Rabin 알고리즘이 있다

이 알고리즘들 중에 몇가지를 살펴보겠다.




## Brute Force
소수의 성질을 이용하는 방법인데, <br>
어떤수 n이 소수인지 판별하려면 n으로 나눠어 떨어지는수가 1과 n 자신만 아니면 된다. <br>
따라서 2~n-1 까지 나누었을때, 나누어 떨어지지 않는다면, n은 소수이다.<br>
그러나 이방법은 오래걸린다.<br>


## 에라토스테네스의 접근법
먼저 짝수 인지 홀수 인지 나눠서 짝수인경우는 2를 제외하고 소수가 없으므로 제외시켜준다.<br>
만약 N이 합성수라면 N=a*b 형태가 된다.(a>1 && b>1)<br>
N= √N  ∗√N=a ∗b    로 표현 할 수 있으므로<br>
a와 b 둘중 하나는 적어도 √N  보다 작다.<br>


## Sieve of Eratosthenes
"에라토스테네스의 체" 로 알려진 이 방법은 위의 에라토스테네스의 접근법을 이용하여 소수를 미리 구해놓고 보는 방법이다.<br>
에라토스테네스의 체 는 2부터 지정된 수까지 2의 배수를 번저 모두 지우고, 3의 배수를 다지우고 ….. √N 의 배수까지 모두 지우고 남은 것들이 소수라는 것을 이용한것이다.  대신 이방법을 사용하려면, n개의 저장 공간이 필요하다.<br>
만약 문제에서 여러개의 소수를 판별 해야하는 경우가 온다면 에라토스테네스의 체를 사용하는것이 아마 제일 빠를 가능성이 크다.


이제 에라토스테네스의 접근법을 코드로 작성해보자.<br>
임의의 수 N이 소수인지 판별하려면 √N 까지의 수의 곱으로 나누어 떨어지는지 확인 해야 한다.
또한, 소수인지 테스트 해서 지울때, 이미 지워진 수에대해서는 체크할 필요가 없고<br>
결국 남아있는 수, 즉 소수에 대해서만 test 하면 되기 때문에 시간은 더욱 줄어든다.
~~~
code
~~~

## Wheel Factorization

## Fermat's Little Theorem
~~~
code
~~~
O(logN)

## Miller-Rabin Primality Test
~~~
code
~~~
O(logN3)<br>
아직 미완성이지만 휴가 갔다와서 완성해야지
