# Graph and its representation
그래프는 node(vertex)와 edge로 이루어 져있는 유한집합입니다. edge 는 순서쌍으로 이루어져있는데, (u,v)라고 하면 node u에서 node v로 방향성을 가진 순서쌍을 의미합니다.((u,v)와(v,u) 는 다릅니다!!)

그래프는 여러가지 종류를 가지고 있습니다. 먼저 무향그래프는 edge가 방향성을 가지고 있지 않는 그래프를 의미합니다. 연결은 되어있으나 양방향으로 움직일수 있는 그래프입니다. 그다음 유향그래프는 edge의 방향성이 존제합니다. 가중치 그래프는 각 edge마다 가중치(weight or cost)가 존제하는 그래프입니다.

그래프는 실생활에 많이 쓰입니다.예를 들면 네트워크를 표현하거나 도시사이 전화선이나 길들, 더나아가 social network 까지 많은 실생활에 사용됩니다. 이렇게 여러가지드르이 관계등을 나타낼때 강력한 그래프인것같습니다.

## 그래프의 표현
그래프는 정말 다양하게 표현됩니다. 주로 인접행렬(adjacency matrix)와 인접리스트(adjacency List)로 많이 표현하며 발생률 행렬(incidence matrix) 나 발생률 리스트(incidence list)로도 쓴다고 합니다. 다양하게 표현 할 수 있는 만큼 각각의 장단점이 존재 하므로 상황에 맞춰서 사용하는 것이 중요합니다.

### 인접행렬( adjacency matrix)

인접행렬은 2차원 배열로 만듭니다. 크기는 보통 (노드의개수 x 노드의개수)로 만듭니 . 예를 들어 adj[i][j]는 i 부터 j 까지 에지가 있는지 없는지를 보여줍니다. 만약에 무향그래프인 경우에는 양방향으로 만들어주면 되기 떄문에 무향그래프의 인접행렬은 대칭입니다. 가중치 그래프가 된 경우에는 adj[i][j]값에 가중치를 넣음으로써 구현합니다.

##### 인접행렬의 장단점
인접행렬의 가장 큰 장점은 구현하기 쉽다는 점 입니다. 또한 edge를 수정하는데 O(1)시간이 걸립니다. 따라서 그래프의 edge가 있는지 없는지 같은 판단을 할때에 빠르게 처리할 수 있습니다.

인접행렬읟 단점은 많은 공간을 사용한다는 점입니다. 노드의개수가 100이고 엣지의 개수가 10이면 공간낭비가 많아집니다. 또 이러하 공간낭비로부터 큰 단점하나가 생깁니다. 노드 i에 연결되어있는 노드에 가고싶은경우  총 노드의 개수-1 만큼 adj[i][]를 모두 확인해보아야 하기 떄문에 O(노드의개수)의 시간이 걸린다는 점입니다. 노드의 개수가 적으면 큰 문제는 아니지만 노드의 개수가 100만이고 에지의 개수가 2개라면 모든 노드를 방문하기위해선 엄청 많은 시간이 걸릴것입니다.

### 인접리스트(adjacency List)
인접리스트는 그래프의 연결관계를 링크드 리스트들의 배열로 나타내는 방식입니다.
배열의 크기는 노드의 개수가 됩니다. array[i]는 node i와 연결되어 있는 모든 노드들의 리스트를 의미 합니다. 따라서 유/무향 그래프의 표현은 자동으로 되고, 가중치 그래프의 경우 노드의 링크드 리스트에 넣습니다.  

보통 vector의 배열로 많이 표현합니다. ~~(갓벡터)~~ vector<int> adj[] f를 하면 adj배열에 백터가 주렁주렁 달린 꼴이 됩니다. 가중치 그래프를 표현해야한다면 vector<pair<int,int>> adj[]를 하면 인접노드와 그에 해당하는 가중치까지 한번에 표현할 수 있습니다.

##### 인접행렬의 장단점
인접리스트의 장점은 공간을 효율적으로 사용한다는 점에 있습니다. 앞서 인접행렬이 쓸모 없는 공간까지 할당했던 반면에 인접리스트는 실제로 존재하는 엣지에 대해서만 존제합니다. 따라서 공간복잡도는 O(|노드의개수|+|edge의개수|)가 됩니다. 따라서 하나의 노드에 대해 인접노드를 탐색할때도 O(edge의 개수)이기 때문에 최악의 경우가 아니면 인접행렬보다 빠르게 탐색할 수 있습니다. 링크드 리스트로 구현되어있기 때문에 그래프가 변경되었을때, 특히 node가 추가되거나 감소되었을때 수정 쉽습니다.  

 인접리스트의 단점은 노드i와 노드j 가 연결되어있는지 알고 싶다면 adj[i]의 벡터를 모두 돌면서 확인해야합니다. 이경우 시간복잡도는 O(노드의개수)가 됩니다(최악의 경우).반면에 위의 인접행렬에서는 행렬애 한번 접근하면 되기때문에 상수시간에 해결이 가능합니다.  


 각각의 표현 방식마다 다양한 장단점이 있습니다. 따라서 각 상황에 잘 맞는 자료구조를 선택하는것이 중요합니다.
